// Generated by CoffeeScript 1.7.1
(function() {
  var defaultZoom, display, displayResults, drawMap, getMarker, language, statovalsa, statoOVP, layer, locate, map, mapRadius, markers, refreshRate, resultLimit, seenPosition, updateLanguage,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  map = null;

  layer = null;

  markers = {};  

  seenPosition = {};

  resultLimit = 200;

  refreshRate = 30 * 1000;

  defaultZoom = 16;

// Cambia il linguaggio di default (ma và?)
// metto no-valsa per adesso per lasciare deselezionata l'opzione 
// così da non ricaricarmi tutta la pagina ogni volta
language = 'niente';
statovalsa = 'no-valsa';
statoOVP = 'no-ovp';

jQuery(function() {
  var $;
  $ = jQuery;
  $('select[name="language"]').change(updateLanguage);
  $('select[name="valsa-class"]').change(updatestatovalsa);
  $('select[name="ovp-class"]').change(updatestatoOVP);
  // questa riga qui non mi convince. mi sa troppo di hardcoding duro
  $.bbq.pushState({'statovalsa':'no-valsa'});
  $.bbq.pushState({'statoOVP':'no-ovp'});

  if ($.bbq.getState('lat') && $.bbq.getState('lon')) {
    return display();      
  } else {
    return locate();
  }
});

// Nota come venga definita locate. Usa il trucchetto di incapsulare tutto dentro () perchè vuole che sembri un espressione quando in realtà è una dichiarazione(statement)
// Ref: http://eloquentjavascript.net/10_modules.html
locate = (function(_this) {
  return function() {
    if (Modernizr.geolocation) {
      return navigator.geolocation.getCurrentPosition(function(pos) {
        var lat, lon;
        lat = parseInt(pos.coords.latitude * 10000) / 10000;
        lon = parseInt(pos.coords.longitude * 10000) / 10000;        
  
        $.bbq.pushState({
          lat: lat,
          lon: lon,
          zoom: defaultZoom,
          language: language
        });
        return 
        display();
      }, function(error) {
        var lat, lon, zoom;
        lat = lat = 38.8951;
        lon = -77.0363;
        zoom = defaultZoom;
        $.bbq.pushState({
          lat: lat,
          lon: lon,
          zoom: defaultZoom,
          language: language
        });
        $("#byline").replaceWith("HTML Geo features are not available in your browser ... so here's Washington DC<br><br>");
        return display();
      }, {
        timeout: 10000
      });
    }
  };
})(this);

display = (function(_this) {
  return function() {
    var lat, lon, radius, zoom;
    lat = $.bbq.getState('lat');
    lon = $.bbq.getState('lon');
    zoom = $.bbq.getState('zoom') || defaultZoom;
    language = $.bbq.getState('language') || language;
    statovalsa = $.bbq.getState('statovalsa') || statovalsa ;      
    statovalsa = $.bbq.getState('statoOVP') || statoOVP  ;      
    drawMap(lat, lon, zoom);
    $('select option[value="' + language + '"]').prop('selected', true);
    // $('select option[value="' + statovalsa + '"]').prop('selected', true); 
    radius = mapRadius();      
    if (radius > 10000) {
      radius = 10000;
    }
    if (seenPosition["" + lat + ":" + lon + ":" + radius + ":" + language]) {
      return;
    }
    seenPosition["" + lat + ":" + lon + ":" + radius + ":" + language] = true;    
    // SpinJS icona che se la spinna
    layer.fire('data:loading');
    
    var eseguiWiki, eseguiValsa, eseguiOVP;
    eseguiValsa=statovalsa==='valsa';
    eseguiOVP=statoOVP==='ovp';
    eseguiWiki=language!=='niente';
    // qui chiama wikigeo.js
    if(eseguiWiki){
      geojson([lon, lat], {
        language: language,
        limit: resultLimit,
        radius: radius,
        images: true,
        summaries: true,
        templates: true
      }, displayResults);
    }
    if(eseguiValsa){
      //circoli();
    }
    if(eseguiOVP){
      //minchi!!!
    }
    layer.fire('data:loaded');
    return null;
  };
})(this);



drawMap = (function(_this) {
  return function(lat, lon, zoom) {
    if (!map) {
      map = L.map('map', {
        center: [lat, lon],
        zoom: zoom,
        maxZoom: 17,
        minZoom: 9,    
        editInOSMControlOptions: {}
    
      });
      layer = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 22
      });
      layer.addTo(map);
      // Mapbox
      // 
      // L.mapbox.accessToken = 'pk.eyJ1IjoiY2FydG9taWtlIiwiYSI6IjZfYkZqajAifQ.d6uTFMLHEgrjpFmD_e9kRQ';
// Create a map in the div #map
// var mapBoxLayer = L.mapbox.map('map', 'examples.map-zr0njcqy');
      // var mapBoxLayer = L.mapbox.tileLayer('cartomike.ilg01opb',{}).addTo(map);           
      
      // Stamen
      var stamenLayer = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'
      });

      var baseLayers = {
        "OSM": layer,        
        'Toner' : stamenLayer
      };
        // var overlays = {
        //   "Cities": cities
        // };
        // var cities = new L.LayerGroup();
        // ricordati di aggiungere cities a L.control.layers, una volta fatto, altrimenti non si vedrà nel menu
        ctrl = L.control.layers(baseLayers).addTo(map);


        map.on('dragend', function(e) {
          var center;
          center = map.getCenter();
          $.bbq.pushState({
            lat: center.lat,
            lon: center.lng
          });
          return display();
        });
        return map.on('zoomend', function(e) {
          $.bbq.pushState({
            zoom: map.getZoom()
          });
          return display();
        });
      }
    };
  })(this);

  displayResults = (function(_this) {
    return function(results) {
      var article, marker, _i, _len, _ref;
      _ref = results.features;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        article = _ref[_i];
        // questo è il punto, lui controlla se ha già il marker e nel caso non lo ridisegna,
        //  tu continui inveci ad aggiungerne perchè non fai questo controllo
        if (markers[article.properties.name]) {
          continue;
        }
        if (!article.geometry || !article.geometry.coordinates) {
          console.log("article " + article.properties.name + " missing geo from api");
          continue;
        }
        marker = getMarker(article);
        marker.addTo(map);
        markers[article.properties.name] = marker;
      }
      return layer.fire('data:loaded');
    };
  })(this);

  getMarker = (function(_this) {
    return function(article) {
      var color, help, icon, marker, needsWorkTemplates, pos, summary, template, url, _i, _len, _ref;
      // nota come inverta le coordinate, perchè rispetto a come sono definite in leaflet lui le usa girate (lat/long e non long/lat)
      pos = [article.geometry.coordinates[1], article.geometry.coordinates[0]];
      url = article.id;
      icon = "book";
      color = "blue";
      help = '';
      needsWorkTemplates = ["Copy edit", "Cleanup-copyedit", "Cleanup-english", "Copy-edit", "Copyediting", "Gcheck", "Grammar", "Copy edit-section", "Copy edit-inline", "messages/Cleanup", "Tone"];
      _ref = article.properties.templates;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        template = _ref[_i];
        if (__indexOf.call(needsWorkTemplates, template) >= 0) {
          icon = "icon-edit";
          color = "orange";
          help = "This article is in need of copy-editing.";
        }
        if (template === "Citation needed" || template === "Citation") {
          icon = "icon-external-link";
          color = "orange";
          help = "This article needs one or more citations.";
        }
      }
      if (!article.properties.image) {
        icon = "icon-camera-retro";
        color = "red";
        help = "This article needs an image.";
      }
      marker = L.marker(pos, {
        title: article.properties.name,
        icon: L.AwesomeMarkers.icon({
          icon: icon,
          color: color
        })
      });
      summary = article.properties.summary;
      if (summary && summary.length > 500) {
        summary = summary.slice(0, 501) + " ... ";
      }
      marker.bindPopup("<div class=\"summary\"><a target=\"_new\" href=\"" + url + "\">" + article.properties.name + "</a> - " + summary + " <div class=\"help\">" + help + "</div></div>");
      return marker;
    };
  })(this);

  mapRadius = function() {
    var ne, radius;
    ne = map.getBounds().getNorthEast();
    radius = ne.distanceTo(map.getCenter());    
    return radius;
  };

  updateLanguage = function() {
    var marker, name, newLanguage;
    newLanguage = $(this).val();    
    if (newLanguage !== language) {
      $.bbq.pushState({
        language: newLanguage
      });
      for (name in markers) {
        marker = markers[name];
        map.removeLayer(marker);
      }
      return display();
    }
  };

  var layerValsa;
  updatestatovalsa = function() {    
    var newstatovalsa, statovalsa;
    newstatovalsa = $(this).val();
    statovalsa=$.bbq.getState("statovalsa");
    if (newstatovalsa !== statovalsa) {
      $.bbq.pushState({
        statovalsa: newstatovalsa
      });      
      statovalsa=newstatovalsa;
      if(statovalsa==="valsa"){
        $.getJSON("js/db_valsa_fin.json",function (data) {          
          layerValsa = L.geoJson(data, {
            onEachFeature: function  (feature, layer) {
              var valsaUrl = '<a href="http://valsassinacultura.it/">Valsassinacultura.it</a>' ;
              var titolo = '<b>' + feature.properties.titolo + '</b>';
              var testoLength = 500;
              var testo = feature.properties.descrizione
              var testoTrimmed = testo.substring(0, testoLength) ;                            
              layer.bindPopup(titolo + '<br>' + testoTrimmed  +'...' + '<br>' + '<b>More info at: </b>'+ valsaUrl );              
            }
          }).addTo(map);
        })
      }else{
        map.removeLayer(layerValsa);
      };      
      return display();
    };
  };

  var layerOVP;
  updatestatoOVP = function() {    
    var newstatoOVP, statoOVP;
    newstatoOVP = $(this).val();
    statoOVP=$.bbq.getState("statoOVP");
    if (newstatoOVP !== statoOVP) {
      $.bbq.pushState({
        statoOVP: newstatoOVP
      });      
      statoOVP=newstatoOVP;
      if(statoOVP==="ovp"){
        console.log("dentro OVP"); 





//--------------------------- OVERPASS----------------------------------
//var osmcsymbol2leafletProperties = osmcsymbol2leafletProperties || {};
// metodo per modificare il colore
osmcsymbol2leafletProperties.colorWay = function (features) {
  var split = features.properties.relations[0].reltags["osmc:symbol"].split(":");
  return {
    color: split[0]
  };
};
// --------------------------------
// MAPPA
// --------------------------------
// Attributions
var attr_osm = 'Map data &copy; <a href="http://openstreetmap.org/">OpenStreetMap</a> contributors',
attr_overpass = 'POI via <a href="http://www.overpass-api.de/">Overpass API</a>';

// BBOX della comunità montana
var maxSouthWest = L.latLng(45.783, 9.030),
maxNorthEast = L.latLng(46.28, 9.670),
maxBounds = L.latLngBounds(maxSouthWest, maxNorthEast);
var query = 'http://overpass-api.de/api/interpreter?data=[out:json][timeout:25];relation["route"="hiking"](' +
  maxBounds._southWest.lat + ',' +
  maxBounds._southWest.lng + ',' +
  maxBounds._northEast.lat + ',' +
  maxBounds._northEast.lng +
  ');out body;>;out skel qt;';

console.log(query);

$.getJSON(query,function (data) {
  var geoJsonData = osmtogeojson(data);          
  layerOVP = L.geoJson(geoJsonData, {
    filter: function (features) {
      if (features.geometry.type == 'LineString') {
        return features;
      } else {
        return null;
      }
    },
    style: function (features) {
      if (features.properties && features.properties.relations && features.properties.relations[0].reltags["osmc:symbol"]) {
        return osmcsymbol2leafletProperties.colorWay(features)
      } else {
        return {
          color: "blue"
        }
      }
    },
    onEachFeature: function (feature, layer) {
      layer.bindPopup("<b>" + feature.properties.relations[0].reltags.name + "</b>" + "</br>" + feature.properties.relations[0].reltags.description);
    }
  }).addTo(map);
})
}else{
  console.log("fuori OVP");
  map.removeLayer(layerOVP);
};      
return display();
};
};


}).call(this);



